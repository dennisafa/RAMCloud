GRH related patch

From: Dennis Afanasev <dennis.afa@gmail.com>


---
 src/AbstractLog.h |    2 +-
 src/Infiniband.cc |   46 ++++++++++++++++++++++++++++++++++++++--------
 2 files changed, 39 insertions(+), 9 deletions(-)

diff --git a/src/AbstractLog.h b/src/AbstractLog.h
index 613ded4e..a02ce24a 100644
--- a/src/AbstractLog.h
+++ b/src/AbstractLog.h
@@ -13,7 +13,7 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#ifndef RAMCLOUD_ABSTRACTLOG_H
+#ifndef RAMCLOIUD_ABSTRACTLOG_H
 #define RAMCLOUD_ABSTRACTLOG_H
 
 #include <atomic>
diff --git a/src/Infiniband.cc b/src/Infiniband.cc
index a5283762..5dae4aba 100644
--- a/src/Infiniband.cc
+++ b/src/Infiniband.cc
@@ -630,21 +630,51 @@ Infiniband::QueuePair::plumb(QueuePairTuple *qpt)
         LOG(ERROR, "plumb() on qp in state %d", getState());
         throw TransportException(HERE, "plumb() on qp not in INIT state");
     }
+    // INIT -> RTR -> RTS 
 
     // now connect up the qps and switch to RTR
     memset(&qpa, 0, sizeof(qpa));
-    qpa.qp_state = IBV_QPS_RTR;
-    qpa.path_mtu = IBV_MTU_1024;
-    qpa.dest_qp_num = qpt->getQpn();
-    qpa.rq_psn = qpt->getPsn();
-    qpa.max_dest_rd_atomic = 1;
-    qpa.min_rnr_timer = 12;
-    qpa.ah_attr.is_global = 1;
+    qpa.qp_state = IBV_QPS_RTR; // We want to move to the ready to receive state
+    qpa.path_mtu = IBV_MTU_1024; // The maximum packet size 
+    qpa.dest_qp_num = qpt->getQpn(); // Destination QP number, 24 bits (trace through and see how it is being set)
+    qpa.rq_psn = qpt->getPsn(); // PSN is like a checksum, ensures packets are uncorrupted
+    qpa.max_dest_rd_atomic = 1; // Number of outstanding operations on the dest queue pair
+    qpa.min_rnr_timer = 12; // When we are signaled for a message and the message is not yet there, timeout after 0.12 millisecoonds
+    qpa.ah_attr.is_global = 1; // It's across subnets so we need to specify 
     qpa.ah_attr.dlid = qpt->getLid();
     qpa.ah_attr.sl = 0;
-    qpa.ah_attr.grh.sgid_index = 0;
+    qpa.ah_attr.grh.sgid_index = 1;
     qpa.ah_attr.src_path_bits = 0;
     qpa.ah_attr.port_num = downCast<uint8_t>(ibPhysicalPort);
+    const int rc = ibv_query_gid(infiniband.device.ctxt, qpa.ah_attr.port_num, qpa.ah_attr.grh.sgid_index, &qpa.ah_attr.grh.dgid);
+    if (rc) {
+       const char* errorstr = strerror(rc);
+       LOG(ERROR, "failed to query GID index %d of port %d in device %s",
+          qpa.ah_attr.grh.sgid_index,
+          qpa.ah_attr.port_num,
+          ibv_get_device_name(infiniband.device.ctxt->device)
+      );
+      LOG(ERROR, "ibv_query_gid failed with errorstr %s", errorstr);
+      throw TransportException(HERE, rc);
+    }
+    std::string gid_raw = "";
+    for (int i = 0; i < 16; ++i) {
+      gid_raw += std::to_string(attr.grh.dgid.raw[i]);
+    }
+    LOG(ERROR, "gid.raw == %s", gid_raw.c_str());
+
+
+    //
+    // struct ibv_ah_attr {
+	//  struct ibv_global_route	grh;
+	//  uint16_t		dlid;
+	//  uint8_t			sl;
+	//  uint8_t			src_path_bits;
+	//  uint8_t			static_rate;
+	//  uint8_t			is_global;
+	//  uint8_t			port_num;
+    // }
+
     LOG(ERROR, "\n Portnum %d \n qp_num %d \n rq_psn %d \n dlid %d \n", ibPhysicalPort, qpt->getQpn(), qpt->getPsn(), qpt->getLid());
 
     r = ibv_modify_qp(qp, &qpa, IBV_QP_STATE |
